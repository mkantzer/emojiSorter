package main

import (
	"context"
	"log"
	"net/http"
	"os"
	"os/signal"
	"time"

	"github.com/dstotijn/go-notion"
	"github.com/gorilla/mux"
	"github.com/mkantzer/emojiSorter/internal/api"
	"github.com/mkantzer/emojiSorter/internal/db"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

type app_info struct {
	App     string
	Version string
}

func (a app_info) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddString("app", a.App)
	enc.AddString("version", a.Version)
	return nil
}

func main() {

	/*
		############################################################
		################## LOGGER CONFIG ###########################
		############################################################
	*/

	logger, err := zap.NewProduction()
	if err != nil {
		log.Fatalf("can't initialize zap logger: %v", err)
	}
	zap.ReplaceGlobals(logger)
	defer logger.Sync() // flushes buffer, if any

	app := &app_info{
		App:     "emojiSorter",
		Version: os.Getenv("APP_VERSION"),
	}

	sugar := logger.Sugar().With(
		zap.Object("app_info", app))
	sugar.Info("logger constrcution succeeded")

	/*
		############################################################
		################## DATASTORE CONFIG ########################
		############################################################
	*/

	// create notion database client
	notionAPIKey, ok := os.LookupEnv("NOTION_API_KEY")
	if !ok {
		sugar.Fatal("NOTION_API_KEY not set")
	}
	client := notion.NewClient(notionAPIKey)

	dbID, ok := os.LookupEnv("NOTION_DB_ID")
	if !ok {
		sugar.Fatal("NOTION_DB_ID not set")
	}

	/*
		############################################################
		################## DATASTORE USAGE? ########################
		############################################################
	*/

	nextVote, err := db.FindVoteTarget(context.Background(), client, dbID)
	if err != nil {
		sugar.Fatalf("Error finding a vote target: %v", err)
	}

	sugar.Infow("vote found",
		"emojiID", nextVote.ID,
		"name", nextVote.Name,
		"imageURL", nextVote.ImageURL,
		"AliasFor", nextVote.AliasFor,
	)

	/*
		############################################################
		################## SERVER CONFIG ########################
		############################################################
	*/
	// for graceful shutdown
	wait := time.Duration(time.Second * 5)

	r := mux.NewRouter()
	r.HandleFunc("/healthz", api.HealthCheckHandler)
	r.HandleFunc("/", api.DummyHandler)
	// r.HandleFunc("/", VotingHandler)
	// r.HandleFunc("/emoji/{name}", SpecificEmojiHandler)
	// r.HandleFunc("/results", ResultHandler)

	// addLoggingMiddleware := api.LoggingMiddleware(sugar)
	// loggedRouter := addLoggingMiddleware(r)

	srv := &http.Server{
		// Handler: loggedRouter,
		Handler: r,
		Addr:    "0.0.0.0:8080",
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	// Run our server in a goroutine so that it doesn't block.
	go func() {
		if err := srv.ListenAndServe(); err != nil {
			sugar.Errorf("server shutdown with error:", err)
		}
	}()

	c := make(chan os.Signal, 1)
	// We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
	// SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
	signal.Notify(c, os.Interrupt)

	sugar.Info("listening on port 8080")

	// Block until we receive our signal.
	<-c

	// Create a deadline to wait for.
	ctx, cancel := context.WithTimeout(context.Background(), wait)
	defer cancel()
	// Doesn't block if no connections, but will otherwise wait
	// until the timeout deadline.
	srv.Shutdown(ctx)
	// Optionally, you could run srv.Shutdown in a goroutine and block on
	// <-ctx.Done() if your application should wait for other services
	// to finalize based on context cancellation.
	sugar.Info("shutting down")
	os.Exit(0)
}
